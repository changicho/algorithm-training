# 231. Power of Two

[링크](https://leetcode.com/problems/power-of-two/)

| 난이도 |
| :----: |
|  Easy  |

## 설계

### 시간 복잡도

int형의 범위로 N이 주어진다.

2의 배수의 경우 2진수로 나타내었을 때 1이 하나만 존재하는 경우이다.

따라서 계속 2로 나누는것을 반복해 문제를 풀이할 수 있다.

이 경우 최대 32번 나누면 되므로 시간 복잡도는 O(1)이다.

### 공간 복잡도

나눗셈을 이용해 풀이할 경우 별도의 공간이 필요하지 않다.

### 나누기

| 내 코드 (ms) | 시간 복잡도 | 공간 복잡도 |
| :----------: | :---------: | :---------: |
|      0       |    O(1)     |    O(1)     |

2의 배수인지 판별하기 위해 2진수로 변환했을 때 1이 한번만 나타나는지를 검사한다.

이를 위해 제일 끝 비트가 1이 나올 때 까지 계속 2로 나눈다.

이렇게 나눈 수가 1이면 2진수이고 1이 아닌경우는 2진수가 아니다. (1인 비트가 여러개)

이때 입력받은 수가 음수, 0인경우는 2의 배수가 절대로 될 수 없으므로 예외 처리한다.

```cpp
bool isPowerOfTwo(int n) {
  if (n <= 0) return false;

  while (!(n & 1)) {
    n >>= 1;
  }

  return n == 1;
}
```

나누기와 나머지를 이용할 경우 다음과 같이 구현할 수 있다.

```cpp
bool isPowerOfTwo(int n) {
  if (n <= 0) return false;

  while (n % 2 != 1) {
    n /= 2;
  }

  return n == 1;
}
```

### n & (n-1)

| 내 코드 (ms) | 시간 복잡도 | 공간 복잡도 |
| :----------: | :---------: | :---------: |
|      0       |    O(1)     |    O(1)     |

앞의 방법에서 이야기했듯이 2의 배수인 경우는 1인 비트가 하나인 경우이다.

따라서 n - 1의 경우는 최상단 1인 비트를 0으로 바꾸고 오른쪽 나머지 비트를 전부 1로 바꾸게 된다.

이를 이용해 n & (n-1)을 수행하면 2의 배수의 경우 0이 나오게된다.

2의 배수가 아닌수의 경우는 제일 오른쪽에 있는 1인 비트만 영향을 받고 나머지 비트들은 남아있으므로 0 초과인 수가 나온다.

```cpp
bool isPowerOfTwo(int n) {
  if (n <= 0) return false;

  return (n & (n - 1)) == 0;
}
```

## 고생한 점
