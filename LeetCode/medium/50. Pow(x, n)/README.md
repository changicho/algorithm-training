# 50. Pow(x, n)

[링크](https://leetcode.com/problems/powx-n/)

| 난이도 |
| :----: |
| Medium |

## 설계

### 시간 복잡도

x의 절대값은 최대 100.0 인 실수이다.

N은 -2^31 ~ 2^31-1인 정수이다.

브루트 포스로 문제를 해결할 경우 최악의 경우 2^31번을 수행해야 하며 이는 제한시간 내에 불가능하다.

따라서 분할 정복을 이용해 문제를 풀이한다.

이 경우 시간 복잡도는 O(log_2(N))이다.

### 공간 복잡도

절반씩 연산 결과를 저장할 공간이 필요하며 이는 상수이다.

따라서 필요한 공간 복잡도는 O(1)이다.

### 분할 정복

| 내 코드 (ms) | 시간 복잡도 | 공간 복잡도 |
| :----------: | :---------: | :---------: |
|      0       | O(log_2(N)) |    O(1)     |

STL pow를 이용할 경우 다음과 같다.

```cpp
double myPow(double x, int n) {
  return pow(x, n);
}
```

N이 매우 클 경우를 대비해서 문제를 나눠 생각해보자

X를 N번 만큼 곱하는 것은 X를 N/2번 만큼 곱한것의 제곱이다.

즉 우리는 N을 분할 정복할 수 있다.

따라서 N/2번 까지 곱을 구할 경우 나머지 N/2번까지의 곱은 구할 필요가 없다.

이 때 N이 홀수인 경우를 예외처리 해야한다.

임계값은 N이 0이거나 1일때이다.

만약 N이 음수가 들어오는 경우는 반대로 1을 제곱한 값으로 나눠준다.

이 때 int의 INT_MIN 에 -1을 곱한 값이 INT_MAX 를 초과함에 유의한다.

```cpp
double myPow(double x, int n) {
  if (n < 0) {
    return 1.0 / (myPow(x, -(n + 1)) * x);
  }
  if (n == 0) {
    return 1;
  }
  if (n == 1) {
    return x;
  }

  double half = myPow(x, n / 2);
  if (n % 2 == 0) {
    return half * half;
  }
  return half * half * x;
}
```

## 고생한 점

INT_MIN 에 -1을 곱한 값이 INT_MAX 를 초과하는것의 처리
