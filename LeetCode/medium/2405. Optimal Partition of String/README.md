# 2405. Optimal Partition of String

[링크](https://leetcode.com/problems/optimal-partition-of-string/description/)

| 난이도 |
| :----: |
| Medium |

## 설계

### 시간 복잡도

문자열 s의 길이를 N이라 하자.

문자열을 왼쪽에서 부터 순회하며 현재까지 문자열에 현재 문자가 존재할 경우 직전의 문자열을 분할하고 문자열을 초기화한다.

이 경우 순회에 O(N)의 시간 복잡도를 사용한다.

### 공간 복잡도

방문 배열을 선언하는 데 O(1)의 공간 복잡도를 사용한다.

비트마스크를 이용해 방문을 관리할 경우 O(1)의 공간 복잡도를 사용한다.

### 순회 & 방문

| 내 코드 (ms) | 시간 복잡도 | 공간 복잡도 |
| :----------: | :---------: | :---------: |
|      18      |    O(N)     |    O(1)     |

왼쪽에서 부터 현재 문자를 순회하며 방문 처리한다.

이 떄 현재 문자가 이전에 방문한 경우, 현재 문자 이전까지 문자열을 분할하고 현재 문자부터 새로운 문자열의 시작점으로 설정하며 탐색을 이어나간다.

이는 순회를 진행하며 최대한 많은 문자를 문자열에 포함시켜 가장 적은 수의 분할 문자열을 만들기 위한 방법이다.

```cpp
int partitionString(string s) {
  int visited = 0;

  int answer = 0;
  for (char &c : s) {
    if (visited & (1 << (c - 'a'))) {
      visited = 0;
      answer++;
    }

    visited |= (1 << c - 'a');
  }
  return answer + 1;
}
```

## 고생한 점
