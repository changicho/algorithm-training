# 808. Soup Servings

[링크](https://leetcode.com/problems/soup-servings/description/)

| 난이도 |
| :----: |
| Medium |

## 설계

### 시간 복잡도

입력받은 수를 N이라 하자.

숫자 A와 B는 25, 50, 75, 100씩 감소하므로 25 단위로 생각해 풀이할 수 있다.

동적 계획법을 이용해 모든 경우를 탐색할 경우 시간 복잡도는 O(N^2)이다.

여기서 N이 매우 커질경우 정답은 1에 가까워지므로 특정 숫자 이상인 경우는 1을 반환할 수 있다.

이는 대략 N이 4800이상인 경우이므로 결국 최종 시간 복잡도는 O((4800/25)^2), O(1)이다.

### 공간 복잡도

N이 특정 수 이하인 경우만 메모이제이션을 적용하면 되므로 O(1)의 공간 복잡도를 사용한다.

### 동적 계획법

| 내 코드 (ms) | 시간 복잡도 | 공간 복잡도 |
| :----------: | :---------: | :---------: |
|      0       |    O(1)     |    O(1)     |

감소하는 수의 단위가 25이기 때문에 각 수를 25로 나눈 값을 이용할 수 있다.

이 때 A와 B에 남아있는 수의 경우에 대해 동적 계획법을 적용할 수 있다.

현재 경우마다 다음 4가지 경우를 탐색한다.

- A에서 100을 뺌
- A - 75, B - 25
- A - 50, B - 50
- A - 25, B - 75

즉 현재 경우마다 4가지 하위 경우들이 존재한다. (각 하위 케이스 마다 1/4의 확률)

각 경우마다 결국 A와 B의 상태가 겹치는 경우가 존재하기 때문에 이를 메모이제이션을 적용할 수 있다.

여기서 A와 B가 둘다 0 이하가 되는 경우는 확률의 절반을 더하므로 0.5를 반환한다.

A만 0이하가 되는 경우는 1.0을 반환한다.

이를 구현하면 다음과 같다.

```cpp
double memo[200][200];

double recursive(int a, int b) {
  if (a <= 0 && b <= 0) return 0.5;
  if (a <= 0) return 1;
  if (b <= 0) return 0;

  if (memo[a][b] > 0) return memo[a][b];

  memo[a][b] = (recursive(a - 4, b) + recursive(a - 3, b - 1) +
                recursive(a - 2, b - 2) + recursive(a - 1, b - 3)) /
                4.0;

  return memo[a][b];
}

// when n = 4800, the result = 0.999994994426
// so return 1 instead
double soupServings(int n) {
  if (n >= 4800) return 1;

  int m = ceil(n / 25.0);

  return recursive(m, m);
}
```

## 고생한 점
