# 68647. 짝수 행 세기

[링크](https://programmers.co.kr/learn/courses/30/lessons/68647)

| 난이도 | 완료 (명) |
| :----: | :-------: |
|  lv4   |    114    |

## 설계

### 시간 복잡도

행의 개수를 R, 열의 개수를 C이라 하자.

조합의 수를 구해야 하며 이는 최대 0 ~ R까지의 조합을 구해야 하므로 조합을 구하는 데 O(R^2)의 시간 복잡도가 소요된다.

각 열에 대해 현재 열에 대한 경우의 수를 count하기 위해 동적 계획법을 사용한다.

이 때 각 열마다 1의 개수에 대해서 순회를 지속하며 1은 한 열에 최대 R개까지 포함할 수 있다.

이 dp를 채우는 순회에 O(R \* C)만큼의 시간 복잡도가 소요된다.

따라서 시간 복잡도는 O(R^2)이다. (R이 C보다 크다고 가정)

### 공간 복잡도

동적 계획법과 조합의 수를 저장할 공간이 필요하며 이에 O(R^2)크기의 공간이 필요하다.

### 조합

각 행에서 1의 개수가 X개일때의 조합은 combination(R,X)라 하자.

여기서 X는 최대 0부터 R개까지 가능하므로 조합들을 미리 구해놓는다.

파스칼의 법칙을 이용해 이전 식을 이용해 구할 수 있다.

```cpp
combination[n][r] = combination[n - 1][r - 1] + combination[n - 1][r]
```

### 1의 개수

각 행에 들어있는 1의 개수를 짝수를 유지해야 한다.

또한 두 행렬의 각 열에 대한 1의 개수가 같아야 한다.

이를 위해서 각 열에 대한 1의 개수를 미리 세준다.

```cpp
for (int row = 0; row < rows; row++) {
  for (int col = 0; col < cols; col++) {
    ones[col] += board[row][col];
  }
}
```

#### 동적 계획법

다음과 같이 행렬의 행을 정의하자.

- 짝수행 : 행에 존재하는 1의 개수가 짝수개인 경우
- 홀수행 : 행에 존재하는 1의 개수가 홀수개인 경우

다음과 같이 일반식을 정의하자.

```cpp
dp[c][r] = x; // 첫 번째 열부터 c번째 열(col)까지 r개의 짝수행(row)을 가진 배열의 경우의 수
```

첫번째 열에 대한 dp값은 첫번째 열에 존재하는 1의 개수를 이용해 짝수행의 개수를 구할 수 있다.

(0과 1을 어떻게 배열할지 시작의 경우의 수 배열)

두번쨰 열부터 dp값은 이전 열의 상태에 따라서 짝수행의 개수를 구할 수 있다.

이때 n번째 열에서 n-1 번째 열에 있는 짝수행에 접근할 수 있다.

그리고 현재 열에 있는 1의 개수에 따라 새로운 짝수행과 홀수행이 만들어질 것이다.

현재 존재하는 1의 개수를 curOnes개라고 했을때 curOnes개의 1은 항상 기존 행에 추가되어야 한다.

이때 기존행이 짝수이냐 홀수이냐에 따라 다음과 같은 규칙이 발생한다.

- 기존 짝수행에 1이 추가되는 경우 ➡ 홀수행
- 기존 홀수행에 1이 추가되는 경우 ➡ 짝수행

우리가 구해야하는 것은 짝수행이 되는 경우이다.

여기서 짝수행 + 홀수행 = 행의 개수 이므로 둘 중 하나만 알면 다른 짝수행, 홀수행의 수를 알 수 있다.

기존의 짝수행 중에서 k개를 선택하는 경우의 수

- 이는 곧 combination(r, curOnes)의 경우의 수와 같다.
- rows는 짝수행의 개수이므로, 항상 0 ~ 전체 행의 개수 범위를 모두 탐색하며 구한다.
- k의 범위는 0 ~ curOnes 사이에 있으므로 해당 범위를 모두 탐색하며 구한다.

기존 홀수행 중에서 k개의 1을 제외한 나머지 1을 선택하는 과정

- 기존 홀수행의 개수는 전체 행의 개수 - 기본 짝수행 개수이다. 이를 nextEvenRows라고 표현하자.
- 따라서 기존 홀수행에서 나머지 1을 선택하는 경우의 수는 combination(nextEvenRows, curOnes)로 구할 수 있다.
- nextEvenRows도 결국 행이므로 범위는 rows와 동일하다.

```cpp
for (int col = 1; col < cols; col++) {
  int curOnes = ones[col];

  for (int row = 0; row <= rows; row++) {
    // 짝수행을 가진 배열이 존재하지 않는 경우 계산 X
    if (dp[col][row] == 0) continue;

    for (int one = 0; one <= curOnes; one++) {
      // 기존 짝수행에서 1의 선택을 받지 못한 경우 + 기존 홀수행에 추가되는 나머지 1의 개수
      int nextEvenRows = (row - one) + (curOnes - one);
      if (row < one || nextEvenRows > rows) continue;

      // 짝수행이 만들어 질 수 있는 경우의 수
      // 기존 짝수행에서 k를 선택하는 경우의 수 x 홀수행에서 나머지 1을 선택하는 경우의 수
      long long result = (combination[row][one] * combination[rows - row][curOnes - one]) % MOD;

      // 다음 열까지 짝수행의 개수 += (현재 열까지 짝수행의 개수 x 짝수행이 만들어질 수 있는 경우의 수)
      // dp[col + 1][nextEvenRows]에 해당하는 값이 여러번 등장할 수 있으므로 기존값과 함께 더해줌
      dp[col + 1][nextEvenRows] = (dp[col + 1][nextEvenRows] + dp[col][row] * result) % MOD;
    }
  }
}
```

## 고생한 점

## 참고

[[프로그래머스] LV.4 짝수 행 세기](https://velog.io/@longroadhome/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-LV.4-%EC%A7%9D%EC%88%98-%ED%96%89-%EC%84%B8%EA%B8%B0)

[[ 프로그래머스 [ 월간코드챌린지 ] 짝수 행 세기 ] (C++)](https://yabmoons.tistory.com/583)
