# 알고스팟. 비대칭 타일링

[링크](https://algospot.com/judge/problem/read/ASYMTILING)

| 정답률(\_%) |
| :---------: |
|     54      |

## 설계

### 시간 복잡도

입력받은 크기를 N이라 하자. (N <= 100)

각 경우를 모두 탐색할 경우, 경우의 수가 매우 크므로 제한시간 내에 불가능하다.

따라서 동적 계획법을 이용해 정답을 구한다.

이 경우 각 크기마다의 값을 구하면 되므로 O(N)의 시간 복잡도를 사용한다.

### 공간 복잡도

동적 계획법을 이용해 모든 크기에 대해 값을 구할 경우 O(N)의 공간 복잡도를 사용한다.

## 동적 계획법

| 수행시간(ms) | 시간 복잡도 | 공간 복잡도 |
| :----------: | :---------: | :---------: |
|      0       |    O(N)     |    O(N)     |

각 경우마다 좌우 대칭인 경우를 제외해야 한다.

이는 크기가 N인 모든 경우에서, 크기가 N/2인 경우의 수를 모두 뺀 경우가 된다. (절반에 대칭인 경우로 나머지 절반을 채우는 모든 경우를 제외)

이 때 N의 크기가 짝수인 경우, (N/2 - 1)인 경우 또한 제거해야 한다.

이는 가운데 = 모양의 블록을 놓을 수 있기 때문이다.

따라서 dp식을 각 크기마다 가능한 경우의 수로 생성하고 정답을 구한다.

```cpp
const int MOD = 1e9 + 7;

long long solution(int size) {
  int dp[101] = {
      0,
  };
  dp[0] = 1;
  dp[1] = 1;
  dp[2] = 2;
  dp[3] = 3;

  for (int i = 4; i <= 100; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
    dp[i] %= MOD;
  }

  long long answer = dp[size];
  int mid = (size / 2);
  answer -= dp[mid];
  if (size % 2 == 0 && mid - 1 >= 0) {
    answer -= dp[mid - 1];
  }

  while (answer < 0) {
    answer += MOD;
  }

  return answer;
}
```

## 고생한 점
