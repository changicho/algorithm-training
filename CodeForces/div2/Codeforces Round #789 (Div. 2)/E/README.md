# E. Tokitsukaze and Two Colorful Tapes

[링크](https://codeforces.com/contest/1678/problem/E)

| 난이도 |
| :----: |
| *1900  |

## 설계

### 시간 복잡도

입력받은 size를 N이라 하자.

각 index마다 각 color는 다른 color와 쌍을 이룬다. (같은 color끼리 한쌍도 가능)

이를 그래프 관계로 표현하면 각 정점은 다른 정점으로 이동할 수 있으며, 간선은 최대 1개씩이다.

따라서 하나의 color에서 다른 color들로 이동하며 cycle을 탐색할 때 시간 복잡도는 총 O(N)이다.

cycle의 갯수와 각 cycle에서 높낮이 차(peak, valley)를 만들 수 있는 갯수를 세고 이 값을 이용해 가능한 최대 값을 구할 수 있다.

이 경우 시간 복잡도는 O(N)이다.

### 공간 복잡도

그래프 구조를 생성하는데 O(N)의 공간 복잡도를 사용한다.

cycle을 탐색하는 데 BFS, DFS를 이용할 경우 최대 O(N)의 공간 복잡도를 사용한다.

### 정리

| 내 코드 (ms) | 시간 복잡도 | 공간 복잡도 |
| :----------: | :---------: | :---------: |
|     109      |  O(T * N)   |    O(N)     |

하나의 사이클에서 최대값을 얻기 위해선 peak, valley를 반복해서 나타나게 하는게 유리하다.

(큰값, 작은값, 큰값, 작은값... 순으로)

만약 사이클의 노드의 갯수가 홀수인 경우 맨 마지막 값은 중간 값으로 설정하게 된다.

여기서 예시를 들어보자.

만약 크기가 3인 사이클의 첫번째 숫자와 두번째 숫자가 가장 차이가 많이 나는 값으로 설정했을때, 중간에 다른 수들이 어떻게 채워지도라도 가장 큰 값을 찾는데에 대한 영향은 없는것을 알 수 있다. (a < b < c 일때 b가 무슨값이 되더라도 정답에 영향이 없음)

따라서 각 상황에서 영향이 맨 마지막 숫자를 채우는 관점으로 문제를 볼 수 있다.

따라서 문제에서 주어진 1과 size를 이용해 최대 점수를 바로 찾을 수 있다.

각 사이클에서 실제로 큰 값을 만들기 위해서는 peak, valley 지점에 값을 어떤 값들을 넣느냐에 따라 영향을 받는다.

선택할 수 있는 큰 값들을 peak로 설정하고, 작은 값들을 valley로 설정한다. 각 사이클에서 유요한 peak와 valley의 갯수는 (cycle의 크기 / 2)가 된다. (홀수인 경우 맨 마지막 값은 이도 저도 아님)

각 사이클마다 최종적으로 유효한 peak 혹은 valley의 총 갯수를 c라고 했을 때 정답은 다음공식으로 구할 수 있다.

```cpp
score = 2 * c * (size − c)
```

이를 이용해 정답을 구한다.

## 고생한 점

풀이를 봐도 이해가 잘 되지 않는다. 

peak, valley에 큰 수를 넣는게 유리하다는 것을 알았으나, 이를 직접 대입해 문제를 풀었을 때 정답이 다르다고 나옴.

공식을 산출하는 중간 단계에 뭐가 있는지를 모르겠다.