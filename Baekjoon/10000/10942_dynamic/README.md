# 10942. 팰린드롬?

[링크](https://www.acmicpc.net/problem/10942)

| 난이도  | 정답률(\_%) | 시간 제한(초) |
| :-----: | :---------: | :-----------: |
| Gold II |   28.192    |      0.5      |

## 설계

### 시간 복잡도

숫자 배열의 길이는 최대 2,000 까지이다.

쿼리의 수는 최대 1,000,000개 이므로 매번 팰린드롬을 판단할 경우 시간 복잡도는 O(2,000 \* 1,000,000) 이므로 제한시간 0.5초 내에 불가능하다.

따라서 동적 계획법을 이용해 시간 복잡도를 줄인다.

### 공간 복잡도

칠판에 적은 수는 최대 100,000 까지이다. 이는 int형으로 충분하다.

### 동적 계획법

팰린드롬의 경우 다음 규칙을 따른다.

from ~ to 까지의 문자열이 팰린드롬인지 확인하는 방법은 다음과 같다.

- (from + 1) ~ (to - 1) 까지의 문자열이 팰린드롬인지 여부
- from, to 번째의 문자들이 같은지 여부

두 경우가 모두 충족할 경우 from ~ to 까지의 문자열은 팰린드롬이다.

위 식을 이용해 일반식을 다음과 같이 구할 수 있다.

```cpp
dp[from][to] = (line[from] == line[to]) && dp[from + 1][to -1]
```

dp의 초기값은 다음과 같다.

- 길이가 1인 문자열은 모두 팰린드롬이다.
- 길이가 2인 문자열이 같은경우 팰린드롬이다.

여기서 길이가 2인 문자열 까지 확인하는 이유는 길이가 2인 경우 (from + 1)이 (to - 1)보다 커지기 때문이다.

따라서 다음과 같이 초기값을 세팅한다.

```cpp
dp[0][0] = true;
for (int i = 1; i < N; i++) {
  dp[i][i] = true;
  dp[i - 1][i] = array[i - 1] == array[i];
}
```

이후 검사할 문자열의 길이를 증가시키며 dp를 갱신한다.

```cpp
for (int length = 2; length < N; length += 1) {
  for (int from = 0; from < N - length; from += 1) {
    int to = from + length;

    dp[from][to] = array[from] == array[to] && dp[from + 1][to - 1];
  }
}
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|     212      |       12       |

## 고생한 점
