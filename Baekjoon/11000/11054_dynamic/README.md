# 11054. 가장 긴 바이토닉 부분 수열

[링크](https://www.acmicpc.net/problem/11054)

|  난이도  | 정답률(\_%) | 시간 제한(초) |
| :------: | :---------: | :-----------: |
| Gold III |   52.556    |       1       |

## 설계

### 시간 복잡도

수열의 크기 N은 최악의 경우 최대 1,000까지이다.

최장 증가 배열만을 구하는 것이 아니라, 해당 위치에서 감소하는 것 까지 고려해 최장 길이를 구해야한다.

모든 경우를 탐색하며 각 숫자마다 이전에 부분 수열을 만들 수 있는지 판단하는데 동적 계획법을 이용한다면 N^2 번 만에 모든 수에 대해 구할 수 있다.

이를 반대로 최장 감소하는 수열을 구하는 경우도 시간 복잡도는 N^2이다.

따라서 동적 계획법을 사용한다.

### 공간 복잡도

수의 범위가 전부 1,000 이내 이므로 int형으로 선언한다.

### 동적 계획법

[11053.가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053) 문제에서 dp를 가져올 수 있다.

dp를 다음과 같이 정의한다.

```cpp
int dp_asc[i] // i번째 수를 마지막 원소로 가지는 LIS의 길이
```

초기값은 다음과 같다.

```cpp
// 모든 원소에 대해 자기 자신을 가진 수열을 생성 가능하므로 길이 1인 수열을 만들 수 있다.
dp_asc[] = 1;
```

i를 0부터 N까지 순회하며 dp를 차례대로 (0번째 부터) 채워나간다.

현재 dp를 구할 때 이전의 dp를 이용해 구할 수 있다.

현재 arr[i]의 수가 arr[j] 보다 크고, j까지 LIS가 i까지 LIS보다 큰 경우

j까지 포함한 LIS에 i를 추가하면 가장 큰 LIS를 만들 수 있다.

```cpp
for (int cur = 0; cur < N; cur++) {
  for (int index = 0; index <= cur; index++) {
    if (arr[index] < arr[cur] && dp_asc[cur] <= dp_asc[index]) {
      dp_asc[cur] = dp_asc[index] + 1;
    }
  }
}
```

이와 반대로 최장 감소 부분수열은 다음과 같이 역순으로 탐색하며 구할 수 있다.

(dp 배열의 초기값과 의미는 동일하다)

```cpp
for (int cur = N - 1; cur >= 0; cur--) {
  for (int index = N - 1; index >= cur; index--) {
    if (arr[cur] > arr[index] && dp_desc[index] >= dp_desc[cur]) {
      dp_desc[cur] = dp_desc[index] + 1;
    }
  }
}
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      4       |       0        |

## 고생한 점
