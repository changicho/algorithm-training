# 1946. 신입 사원

[링크](https://www.acmicpc.net/problem/1946)

| 난이도 | 정답률(\_%) | 시간 제한(초) |
| :----: | :---------: | :-----------: |
| 실버 I |   31.683    |       2       |

## 설계

### 시간 복잡도

테스트케이스가 주어지므로 아래의 시간복잡도에 T를 곱한다.

사원의 수를 N이라 하자.

각 사원에 대해서 2가지 항목을 같이 평가해야한다.

한 사원이 다른 모든사원에 비해 떨어질 사유가 존재하는지 전부 판단할 경우 O(N)의 시간 복잡도를 사용하며, 이를 모든 사원에 대해서 수행할 경우 O(N^2)의 시간 복잡도를 사용한다.

이는 제한시간 내에 불가능하다.

미리 하나의 기준으로 정렬을 수행한 후 그리디 알고리즘을 통해서 직전의 비교할 값과 현재 사원을 비교할 수 있다.

이 경우 정렬에 O(N \* log_2(N))을 소요하며, 비교에 O(1)을 사용한다.

입력받은 수는 N이하임이 보장되므로 입력받자마자 해당 index에 값을 넣을 수 있다. (카운팅 정렬 응용)

이 경우 별도의 정렬은 필요하지 않으므로 O(N)의 시간 복잡도로 풀이가 가능하다.

따라서 시간 복잡도는 O(N \* T)이다.

### 공간 복잡도

입력받은 사원들의 정보를 저장할 공간이 필요하며 이에 O(N)의 공간 복잡도를 사용한다.

## 정렬

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|              |                |

사원의 필기등수를 a, 면접등수를 b라 하자.

먼저 입력받은 사원의 정보 중 필기 등수를 index로 사용해 오름차순으로 정렬한다.

이 경우 면접 등수에 대해서만 직전의 값과 비교하면 된다.

이는 이미 필기 등수에 대해 오름차순으로 정렬되어있으므로 필기등수는 더이상 비교할 필요가 없기 때문이다.

해당 인원을 채용하지 못하는 경우는 직전 값보다 (필기 등수가 떨어지는 상황) 면접 등수도 떨어지는 경우이다.

만약 해당 인원을 채용하는 경우, 이후의 값들은 현재 인원의 면접 등수보다는 높아야 채용이 가능하다.

이를 구현하면 다음과 같다.

```cpp
void solution() {
  int N;
  cin >> N;

  vector<int> ranks(N + 1);

  for (int i = 0; i < N; i++) {
    int a, b;
    cin >> a >> b;
    ranks[a] = b;
  }

  int before = ranks[1];
  int answer = 1;
  for (int i = 2; i <= N; i++) {
    if (ranks[i] <= before) {
      before = ranks[i];
      answer++;
    }
  }

  cout << answer << "\n";
}
```

## 고생한 점
