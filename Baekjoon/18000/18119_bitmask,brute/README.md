# 18119. 단어 암기

[링크](https://www.acmicpc.net/problem/18119)

| 난이도  | 정답률(\_%) |
| :-----: | :---------: |
| Gold IV |   45.652    |

## 설계

### 시간 복잡도

N은 최대 10,000 M 은 최대 50,000 까지이다.

각 문자별로 가지고 있을 수 있는 알파벳의 개수는 26개 이다.

각 경우마다 알파벳들을 비교해야 하므로 시간 복잡도는 O(NM)에 각 경우마다 단어를 비교하는데 들어가는 시간복잡도를 곱한다.

```cpp
10,000 * 50,000 = 500,000,000
```

제한 시간은 4초이며 O(NM)만 실행하는데도 매우 아슬아슬하다.

따라서 단어마다 비교는 비트마스크를 이용해 O(1) 만에 수행해야한다.

### 공간 복잡도

비트마스크를 사용할 경우 26자리의 마스크가 필요하다.

2^26 = 67,108,864 이므로 int형으로 충분하다.

### 비트 마스킹

단어를 입력하며 각 단어의 알파벳을 포함하고있으면 1, 아니면 0인 비트마스킹을 만든다.

```cpp
for (int i = 0; i < N; i++) {
  string word;
  cin >> word;

  for (char c : word) {
    alphaBits[i] |= 1 << (c - 'a');
  }
}
```

or 연산을 이용해 1로 바꾸는 방법을 이용한다.

처음에는 모든 알파벳들을 알고있다고 가정하므로 26자리가 모두 1로 채워진 비트를 만든다.

```cpp
int knowAlpha = 0xffffffff; // 모든자리를 1로채움
```

알파벳을 잊거나 기억할 때의 비트마스킹은 다음 방법을 이용해 만든다

```cpp
if (command == '1') {
  knowAlpha &= ~(1 << (alpha - 'a')); // 잊으므로 and연산 (그 자리만 0으로 바꿔야하므로 반전 ~ 사용)
} else {
  knowAlpha |= (1 << (alpha - 'a')); // 기억하므로 or연산
}
```

해당 단어를 기억하는지의 여부는 비트마스킹을 이용해 판별한다.

현재 알고있는 알파벳 비트마스크와 단어의 비트마스크를 and연산한 결과가 알파벳 비트마스크와 같은 경우에 그 단어를 알고있는것이다.

```cpp
if ((alphaBits[i] & knowAlpha) == alphaBits[i]) {
  count++;
}
```

### 컴파일 최적화

```cpp
#pragma GCC optimize("O3")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
```

GCC optimize("O3")을 설정할 경우 gcc(g++)로 컴파일하는 온라인저지에서 강제로 O3로 컴파일하도록 한다.

O3는 코드의 크기는 신경쓰지 않은 채, 수행 시간 향상을 위한 최적화를 모두 수행한다.

그러나 O3가 O2보다 항상 빠르다고 할 수 없으며, 경우에 따라 더 느려지기도 합니다.

Ofast는 GCC 4.7에 추가되었으며, O3에서 사용하는 모든 최적화에 몇 가지 추가적인 최적화를 수행한다.

| 옵션을 사용하지 않은 경우 (ms) | 옵션을 사용한 경우 (ms) |
| :----------------------------: | :---------------------: |
|              448               |           152           |

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|     152      |       32       |

## 고생한 점
