# 13334. 철로

[링크](https://www.acmicpc.net/problem/13334)

| 난이도  | 정답률(\_%) | 시간 제한(초) |
| :-----: | :---------: | :-----------: |
| Gold II |   39.017    |       1       |

## 설계

### 시간 복잡도

N의 최대 개수는 100,000개 까지이다.

각 경로 좌표마다 모두 비교할 경우 시간 복잡도는 O(N^2)이며 이는 제한시간 1초 내에 불가능하다.

따라서 우선순위 큐와 정렬을 이용해 시간 복잡도를 줄여야 한다.

이 때 시간 복잡도는 O(N \* log(N)) 이므로 제한시간 1초 내에 충분하다.

### 공간 복잡도

좌표의 경로는 -100,000,000 ~ 100,000,000 까지이다.

철로의 길이는 200,000,000 까지 이며 이는 int형으로 충분하다.

정답의 개수는 최대 100,000 까지 이므로 int형으로 선언한다.

### 우선순위 큐

우선 순차적으로 비교를 하기 위해 각 경로들을 정렬한다.

이 때 경로의 시작점과 끝점중에 작은쪽을 시작점, 큰쪽을 끝점으로 통일시킨다.

이후 끝점을 기준으로 오름차순으로 모든 경로를 정렬한다.

이 때 끝점이 같은 경우 시작점을 기준으로 오름차순으로 정렬한다.

이후 매 경로마다 (끝점 - 철로의 길이)를 기준으로 시작점들을 비교한다.

각 끝점을 기준으로 자신보다 이전에 존재하는 경로들이 범위에 포함되는지만 확인하면 되기 때문이다.

이때 매 경우마다 비교할 경우 O(N^2) 만큼의 시간이 들어 제한시간 내에 불가능하다.

따라서 시작점을 비교할 때, 이전 경로에서 비교한 정보들을 사용하기 위해 우선순위 큐를 이용한다.

시작점들이 오름차순으로 정렬되어있는 자료구조로 우선순위 큐(힙)을 이용한다.

(우선순위 큐의 제일 위의 값은 제일 작은값)

```cpp
struct Line {
  int from, to;
  // sort
  bool operator<(const Line &B) const {
    if (from != B.to) {
      return to < B.to;
    }
    return from < B.from;
  }
  // priority queue
  bool operator()(Line &A, Line &B) {
    return A.from > B.from;
  }
};
```

```cpp
sort(lines.begin(), lines.end());
priority_queue<Line, vector<Line>, Line> pq;

int answer = 0;
for (Line line : lines) {
  pq.push(line);
  while (!pq.empty() && pq.top().from < line.to - D) {
    pq.pop();
  }
  answer = max(answer, (int)pq.size());
}
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      40      |       16       |

## 고생한 점
