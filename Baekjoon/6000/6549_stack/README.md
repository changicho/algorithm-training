# 6549. 히스토그램에서 가장 큰 직사각형

[링크](https://www.acmicpc.net/problem/6549)

|   난이도   | 정답률(\_%) | 시간 제한(초) |
| :--------: | :---------: | :-----------: |
| Platinum V |   25.412    |       1       |

## 설계

유사한 문제

- [백준.1725.히스토그램](https://www.acmicpc.net/problem/1725)

### 시간 복잡도

직사각형의 수는 최대 100,000개 이다.

N log(N)의 시간 복잡도 이내로 해결해야 하기 때문에 브루트 포스 방법은 불가능하다.

stack의 성질을 이용해 O(N)번 안에 풀이한다.

### 공간 복잡도

각 높이의 최대값은 1,000,000,000 이다. 최악의 경우 정답은 1,000,000,000 \* 100,000 이므로 long long형으로 선언한다.

### 스택

현재 인덱스( index ) 이전의 도형의 높이 중에 (index - 1) ~ (0) 최고 넓이가 나오는 것을 찾는 것이 핵심이다.

index를 순회하며 높이에 대해 오름차순으로 스택에 쌓는다.

- 스택에 들어있는 막대보다 다음의 막대가 크거나 같으면 그냥 스택에 넣는다.
- 그게 아니라면 현재 들어있는 막대 중 다음에 넣을 막대보다 큰 막대들을 전부 빼내며 넓이를 계산한 후 스택에 넣는다.

따라서 스택 안의 오른쪽 끝 막대(top) 기준으로, 왼쪽에 있는 모든 막대는 오른쪽 끝 보다 작은 것이 보장된다.

스택에는 너비를 구하는 과정에 필요한 index를 저장한다.

매번 스택에는 현재 index까지의 과정 중 가장 작은 높이의 막대를 갱신하며,

만약 현재 index번째의 높이가 스택의 top보다 작은 경우, stack을 pop하며 그때까지의 정답을 갱신한다.

이 때 히스토그램의 맨 마지막 막대가 정답인 경우도 고려해야 하므로, 히스토그램 배열의 맨 마지막에 0을 넣어 맨 마지막 경우도 탐색한다.

```cpp
for (int index = 0; index <= N; index++) {
  while (!s.empty() && histograms[s.top()] >= histograms[index]) {
    long long top = s.top();
    s.pop();

    long long width = s.empty() ? index : (index - s.top() - 1);
    answer = max(answer, histograms[top] * width);
  }
  s.push(index);
}
```

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      36      |       4        |

## 고생한 점
