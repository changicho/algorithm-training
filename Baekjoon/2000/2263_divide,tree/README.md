# 2263. 트리의 순회

[링크](https://www.acmicpc.net/problem/2263)

|  난이도  | 정답률(\_%) |
| :------: | :---------: |
| Gold III |   37.552    |

## 설계

### 시간 복잡도

N은 최대 100,000 까지이다.

재귀호출로 트리를 탐색하는 경우 시간 복잡도는 2N 만큼이다.

inOrder가 주어졌으므로 이를 이용해 트리를 생성하는데 재귀호출로 반복하면 되므로 시간복잡도 또한 거의 O(N)이다.

### 공간 복잡도

N이 최대 100,000 까지이며, 각 요소의 값은 100,000 이하의 정수임이 보장되므로 int형으로 사용한다.

### 트리의 성질

후위 순회에서는 맨 마지막에 위치한 노드가 해당 트리의 루트이다.

중이 순회에서는 루트가 나오기 전까지 노드는 왼쪽에, 루트 이후에 나오는 노드들은 오른쪽에 위치한다.

또한 각 오더는 재귀적으로 호출을 반복해 들어갈 수 있다.

1. 후위 순회의 루트의 정보를 이용하여 중위 순회의 root를 찾는다.
2. 좌우를 구분해 재귀호출을 수행한다.

다음 예시를 살펴보자.

| 4   | 2   | 7   | 5   | 1   | 3   | 6   | in order   |
| --- | --- | --- | --- | --- | --- | --- | ---------- |
| 4   | 7   | 5   | 2   | 6   | 3   | 1   | post order |

위 경우 트리의 루트는 1이며, inOrder에서 1의 왼쪽에 있는 부분과 오른쪽에 있는 부분을 각각 별도의 트리로 나눌 수 있다.

| 4   | 2   | 7   | 5   | in order   |
| --- | --- | --- | --- | ---------- |
| 4   | 7   | 5   | 2   | post order |

위는 왼쪽 트리에 대해 재귀호출을 반복한 결과이다.

이 경우에도 왼쪽과 오른쪽을 나눌 수 있다.

이때 루트의 왼쪽과 오른쪽을 구분하기 위해 inOrder 배열에서 각 숫자들의 index를 보관하는 mapping table이 필요하다.

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|      28      |       8        |

## 고생한 점
