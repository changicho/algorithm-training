# D - Masked Popcount

[링크](https://atcoder.jp/contests/abc356/tasks/abc356_d)

| 난이도 |
| :----: |
|  400   |

## 설계

### 시간 복잡도

입력받은 수를 N, M이라 하자.

1부터 N까지 직접 수행할 경우 O(N \* log_2(M))의 시간 복잡도를 사용한다. 이는 제한시간 내에 불가능하다.

각 비트에 대해 추가되는 경우의 수를 구할 수 있다.

이 경우 O(log_2(N))의 시간 복잡도를 사용한다.

### 공간 복잡도

정답을 저장하는 데 long long 형으로 선언해야 한다.

정답 크기에 상수크기의 공간 복잡도를 사용한다.

### 경우의 수

| 내 코드 (ms) | 시간 복잡도 | 공간 복잡도 |
| :----------: | :---------: | :---------: |
|      2       | O(log_2(N)) |    O(1)     |

0부터 N까지 모든 수에 대해서, M과 and연산시에 추가되는 비트의 수를 구한다.

M의 특정 비트가 1일때, 해당 비트의 index를 i라 하자.

이 경우 경우의 수는 다음과 같이 나타낼 수 있다.

- i 왼쪽 숫자들의 경우의 수
- i 오른쪽 숫자들의 경우의 수

이 때 현재 i번째 비트가 1인 경우 N에 따라 경우의 수가 나뉜다.

- N의 i번째 비트가 1인 경우 : 해당 비트를 제외하고 남은 비트로 만든 수 만큼 경우의 수가 생김
- N의 i번째 비트가 0인 경우 : 해당 비트를 N에서 뺀 뒤 새로 만든 비트를 사용함. 이 때 i번째 이하 비트의 경우 모든 경우가 가능

아래와 같은 예시를 사용할 수 있다.

```text
N=4, M=3 일 때
N : 100(2)
M : 011(2)

M의 해당 비트마다 가능한 경우의 수는 다음과 같다.

M의 현재 count할 비트가 OO1일 때

[00]1
[01]1
(아래 경우는 N보다 크므로 불가)
[10]1
[11]1

M의 현재 count할 비트가 010일 때

[0]1[0]
[0]1[1]
(아래 경우는 N보다 크므로 불가)
[1]1[0]
[1]1[1]
```

위 경우는 N과 M의 겹치는 비트가 없어 비트의 왼쪽 부분의 경우의 수를 모두 생성하지 못하는 경우이다.

따라서 N에서 M의 해당 비트를 뺀 값을 이용해 가능한 경우의 수를 계산한다.

만약 겹치는 경우 아래와 같이 판단할 수 있다.

```text
N : 1010(2), M : 0010(2)

M의 현재 count할 비트가 0010일 때
[00]1[0]
[00]1[1]
[01]1[0]
[01]1[1]
[10]1[0]
(아래 경우는 N보다 크므로 불가)
[10]1[1]
[11]1[0]
[11]1[1]
```

위 경우는 N에서 count할 해당 비트를 제거한 비트만큼 경우의 수가 생기는 것을 알 수 있다.

이를 구현하면 다음과 같다.

```cpp
int solution(ll n, ll m) {
  const ll MOD = 998244353;

  for (ull i = 0; i < 64; i++) {
    if (m & (1ULL << i) && n < (1ULL << i)) {
      m -= (1ULL << i);
    }
  }

  ll answer = 0;

  for (ull i = 0; i < 64; i++) {
    if (m & (1LL << i)) {
      ll temp, totalLeft, totalRight;
      if (n & (1LL << i)) {
        temp = n;
        totalLeft = ((temp >> (i + 1)) << i);
        totalRight = temp % (1LL << i);
      } else {
        temp = n - (1LL << i);
        totalLeft = ((temp >> (i + 1)) << i);
        totalRight = ((1LL << i) - 1);
      }

      ll totalCase = totalLeft + totalRight;

      answer += totalCase + 1;
      answer %= MOD;
    }
  }

  return answer;
}
```

## 고생한 점
